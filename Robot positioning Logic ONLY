/*This code only accounts for the logic of the triangulation of IR positioning of
the robot. Another code is available on the GitHub repo for true implementation. This 
version is only for logic and testing.*/



#include <iostream>
#include <cmath>
#include <vector>
using namespace std;

// ------------------- BEACON COORDINATES -------------------
//These coordinates are interchangeable, and can be changed to any
//positive value
const float bx1 = 0.0;
const float by1 = 0.0;
const float bx2 = 0.0;
const float by2 = 100.0;
const float bx3 = 50.0;
const float by3 = 100.0;

//Gives an ID to each beacon and calculates the time
//between each beacon detection
struct Detection {
    int id;
    float time;
};

vector<Detection> detections;

// ------------------------- UTILS ---------------------------
float degToRad(float deg) { return deg * M_PI / 180.0; }
float radToDeg(float rad) { return rad * 180.0 / M_PI; }

// ------------ LINE INTERSECTION BETWEEN 2 BEACONS ----------
bool linesBeacons(float xA, float yA, float alphaA,
                  float xB, float yB, float alphaB,
                  float &rx, float &ry) 
{
    float ux = -cos(alphaA);
    float uy = -sin(alphaA);
    float vx = -cos(alphaB);
    float vy = -sin(alphaB);

    float dx = xB - xA;
    float dy = yB - yA;

    float denom = (ux * (-vy) - uy * (-vx));
    if (fabs(denom) < 1e-6) return false;

    //Calculates the coordinates ofmiddle of the line (M)
    //from beacon X to beacon Y
    float s = (dx * (-vy) - dy * (-vx)) / denom;
    rx = xA + s * ux;
    ry = yA + s * uy;
    return true;
}

// -------------------- TRIANGULATION LOGIC ------------------
bool robotPosition(float &finalX, float &finalY) 
{
    if (detections.size() < 4) return false;

    int i0 = 0;
    int i1 = -1, i2 = -1, i3 = -1;
    int id0 = detections[0].id;

    // find pattern of beacons A B C A
    for (int i = 1; i < detections.size(); i++) {
        if (detections[i].id != id0 && i1 == -1) { i1 = i; continue; }
        if (i1 != -1 && detections[i].id != id0 && detections[i].id != detections[i1].id && i2 == -1) { i2 = i; continue; }
        if (i2 != -1 && detections[i].id == id0) { i3 = i; break; }
    }

    //If no detection is made, report the error
    if (i1 == -1 || i2 == -1 || i3 == -1) return false;

    float t1 = detections[i0].time;
    float t2 = detections[i1].time;
    float t3 = detections[i2].time;
    float t4 = detections[i3].time;

    //timestamps between each beacons
    float dt12 = t2 - t1;
    float dt23 = t3 - t2;
    float dt34 = t4 - t3;
    float dt14 = t4 - t1;

    if (dt14 <= 0) return false;

    //Calculate angle from each triangle
    float angle12 = (dt12 / dt14) * 360.0;
    float angle23 = (dt23 / dt14) * 360.0;
    float angle31 = (dt34 / dt14) * 360.0;

    int idA = detections[i0].id;
    int idB = detections[i1].id;
    int idC = detections[i2].id;

    float bA = 0;
    float bB = angle12;
    float bC = angle12 + angle23;

    float alphaA = degToRad(fmod(bA+360,360)); // Calculates floating point remainder
    float alphaB = degToRad(fmod(bB+360,360));
    float alphaC = degToRad(fmod(bC+360,360));

    float Ax, Ay, Bx, By, Cx, Cy;

    //Lambda function (helper function)
    auto beaconCoord = [&](int id, float &x, float &y){
        if (id == 1){ x=bx1; y=by1; }
        else if(id==2){ x=bx2; y=by2; }
        else{ x=bx3; y=by3; }
    };

    beaconCoord(idA, Ax, Ay);
    beaconCoord(idB, Bx, By);
    beaconCoord(idC, Cx, Cy);

    //Calculate 3 distances from the 3 triangles
    float rx1, ry1, rx2, ry2, rx3, ry3;
    bool ok12 = linesBeacons(Ax, Ay, alphaA, Bx, By, alphaB, rx1, ry1);
    bool ok23 = linesBeacons(Bx, By, alphaB, Cx, Cy, alphaC, rx2, ry2);
    bool ok31 = linesBeacons(Cx, Cy, alphaC, Ax, Ay, alphaA, rx3, ry3);

    int ok = 0;
    float sumX = 0, sumY = 0;

    if (ok12){ sumX+=rx1; sumY+=ry1; ok++; }
    if (ok23){ sumX+=rx2; sumY+=ry2; ok++; }
    if (ok31){ sumX+=rx3; sumY+=ry3; ok++; }

    if (ok == 0) return false;

    //Find the average and use it as the final coordinates
    finalX = sumX / ok;
    finalY = sumY / ok;
    return true;
}

// ----------------------------- MAIN -----------------------
int main() 
{
    cout << "Enter detections in format: <beaconID> <timestamp_ms>\n";
    cout << "Enter 4 detections in order A B C A.\n\n";

    detections.clear();
    for (int i = 0; i < 4; i++) {
        Detection d;
        cout << "Detection " << i+1 << ": ";
        cin >> d.id >> d.time;
        detections.push_back(d);
    }

    float rx, ry;
    bool ok = robotPosition(rx, ry);

    if (!ok) {
        cout << "\nTriangulation Failed.\n";
    } else {
        cout << "\nEstimated Robot Position:\n";
        cout << "X = " << rx << endl;
        cout << "Y = " << ry << endl;
    }

    return 0;
}
